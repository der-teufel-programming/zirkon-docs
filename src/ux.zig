const std = @import("std");

const autodoc = @import("Autodoc.zig");
const render = @import("render.zig");
const gemini_render = @import("gemini/render_source.zig");
const main_js = @import("gemini/main_js.zig");

pub const GeminiOptions = struct {
    project_page: ?[]const u8,
    project_name: ?[]const u8,
};

pub fn gemini_main(
    alloc: std.mem.Allocator,
    data: autodoc.DocData,
    output_dir_path: []const u8,
    src_dir_path: []const u8,
    options: GeminiOptions,
) !void {
    var output_dir = try std.fs.cwd().makeOpenPath(output_dir_path, .{});
    defer output_dir.close();

    var index = try GemFile.init(alloc, "index.gmi", output_dir);
    defer index.close();

    const root_mod = data.modules[data.rootMod];
    const root_mod_name = root_mod.name;
    const heading = try std.fmt.allocPrint(
        alloc,
        "Generated documentation for: {s}",
        .{root_mod_name},
    );
    defer alloc.free(heading);
    try index.doc.addHeading(.h1, heading);
    try index.doc.addText("This is the index file for a set of gemini documents rendered from data generated by Zig's Autodoc for this module.");
    try index.doc.addLink("by_ns/index.gmi", "Default documentation (by namespace)");
    try index.doc.addLink("by_file/index.gmi", "Documentation by file");
    try index.doc.addLink("modules.gmi", "All modules");
    try index.doc.addLink("src/index.gmi", "Rendered source of all files included in the data");
    try index.doc.addHeading(.h2, "Links:");
    if (options.project_page) |page| {
        try index.doc.addHeading(.h3, "This project:");
        try index.doc.addLink(page, options.project_name);
        try index.doc.addHeading(.h3, "Other links:");
    }
    try index.doc.addLink("https://ziglang.org", "Zig programming language");
    try index.doc.addLink("https://github.com/der-teufel-programming/zirkon-docs", "Zirkon - the tool used to create this page");

    try index.write();

    try renderSources(
        alloc,
        output_dir,
        src_dir_path,
        data.files,
    );

    try renderModules(
        alloc,
        output_dir,
        "modules.gmi",
        data.modules,
        data.rootMod,
    );

    var ns_dir = try output_dir.makeOpenPath("by_ns", .{});
    defer ns_dir.close();

    const root_mod_type = root_mod.main;
    var root_doc = try GemFile.init(alloc, "index.gmi", ns_dir);
    defer root_doc.close();

    var main_js_inst: main_js = .{ .alloc = alloc, .data = data, .canvas = &root_doc.doc };
    try main_js_inst.renderContainer(root_mod_type, "root");
    try root_doc.write();
}

const GemFile = struct {
    file: std.fs.File,
    doc: render.Document,

    pub fn init(
        alloc: std.mem.Allocator,
        file_path: []const u8,
        dir: std.fs.Dir,
    ) !GemFile {
        return .{
            .doc = render.Document.init(alloc),
            .file = try dir.createFile(file_path, .{}),
        };
    }

    pub fn close(self: GemFile) void {
        self.file.close();
        self.doc.deinit();
    }

    pub fn write(self: *GemFile) !void {
        try self.doc.renderTo(self.file.writer());
    }

    pub fn clearDoc(self: *GemFile) void {
        self.doc.text.clearRetainingCapacity();
    }
};

fn renderSources(
    alloc: std.mem.Allocator,
    output_dir: std.fs.Dir,
    src_dir_path: []const u8,
    files: []const autodoc.File,
) !void {
    var src_dir = output_dir.openDir("src", .{}) catch |err| blk: {
        switch (err) {
            error.FileNotFound => {
                try output_dir.makeDir("src");
                break :blk try output_dir.openDir("src", .{});
            },
            else => return err,
        }
    };
    defer src_dir.close();

    var raw_src_dir = try std.fs.cwd().openDir(src_dir_path, .{});
    defer raw_src_dir.close();

    var src_idx = try GemFile.init(alloc, "index.gmi", src_dir);
    defer src_idx.close();

    try src_idx.doc.addHeading(.h1, "Sources");

    var elems = std.ArrayListUnmanaged([]const u8){};
    defer elems.deinit(alloc);

    for (files) |file| {
        const gen_name = try std.fmt.allocPrint(
            alloc,
            "{s}.gmi",
            .{std.fs.path.basename(file.name)},
        );
        defer alloc.free(gen_name);

        var ci = try std.fs.path.componentIterator(file.name);
        defer elems.clearRetainingCapacity();
        while (ci.next()) |comp| {
            try elems.append(alloc, comp.name);
        }
        const file_link = try std.mem.join(alloc, "/", elems.items);
        defer alloc.free(file_link);
        _ = elems.pop();
        try elems.append(alloc, gen_name);
        const real_link = try std.mem.join(alloc, "/", elems.items);
        defer alloc.free(real_link);

        try src_idx.doc.addLink(real_link, file_link);

        const output_file = if (elems.items.len > 1) blk: {
            var dir = try src_dir.makeOpenPath(
                std.fs.path.dirname(file.name) orelse ".",
                .{},
            );
            defer dir.close();
            break :blk try dir.createFile(std.fs.path.basename(gen_name), .{});
        } else try src_dir.createFile(gen_name, .{});
        defer output_file.close();

        const f = raw_src_dir.openFile(file.name, .{}) catch {
            try output_file.writer().print(
                "# {s}\n## Error:\nThis source rendering is unfortunately empty",
                .{file_link},
            );
            continue;
        };
        defer f.close();

        var buff = std.io.bufferedReader(f.reader());
        const reader = buff.reader();
        var r = render.ZigRender.init(alloc, true);
        defer r.deinit();

        try gemini_render.genSrc(alloc, reader, file_link, &r);
        try r.doc.renderTo(output_file.writer());
    }

    try src_idx.write();
}

fn renderModules(
    alloc: std.mem.Allocator,
    output_dir: std.fs.Dir,
    modules_file_path: []const u8,
    modules: []const autodoc.Module,
    root: usize,
) !void {
    var modules_file = try GemFile.init(alloc, modules_file_path, output_dir);
    defer modules_file.close();

    var mods_dir = output_dir.openDir("mods", .{}) catch |err| switch (err) {
        error.FileNotFound => blk: {
            try output_dir.makeDir("mods");
            break :blk try output_dir.openDir("mods", .{});
        },
        else => return err,
    };
    defer mods_dir.close();

    for (modules, 0..) |mod, idx| {
        const link = try std.fmt.allocPrint(alloc, "mods/{s}.gmi", .{mod.name});
        defer alloc.free(link);
        var mod_f = try GemFile.init(
            alloc,
            std.fs.path.basenamePosix(link),
            mods_dir,
        );
        defer mod_f.close();

        try modules_file.doc.addLink(link, mod.name);

        try mod_f.doc.addHeading(.h1, mod.name);
        try mod_f.doc.addHeading(.h2, "Docs");
        if (idx == root) {
            try mod_f.doc.addLink("../by_ns/index.gmi", "Main type");
        } else {
            try mod_f.doc.addLink("../by_ns/path.gmi", "Main type");
        }
        try mod_f.doc.addHeading(.h2, "Import table");
        var it = mod.table.iterator();
        while (it.next()) |entry| {
            const table_link = try std.fmt.allocPrint(
                alloc,
                "{s}.gmi",
                .{entry.key_ptr.*},
            );
            defer alloc.free(table_link);
            try mod_f.doc.addLink(table_link, entry.key_ptr.*);
        }

        try mod_f.write();
    }
    try modules_file.write();
}
