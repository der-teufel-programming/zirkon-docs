const std = @import("std");

const autodoc = @import("Autodoc.zig");
const render = @import("render.zig");
const gemini_render = @import("gemini/render_source.zig");

pub const GeminiOptions = struct {
    project_page: ?[]const u8,
    project_name: ?[]const u8,
};

pub fn gemini_main(alloc: std.mem.Allocator, data: autodoc.DocData, output_dir_path: []const u8, src_dir_path: []const u8, options: GeminiOptions) !void {
    var output_dir = try std.fs.cwd().makeOpenPath(output_dir_path, .{});
    defer output_dir.close();
    var index_doc = render.Document.init(alloc);
    defer index_doc.deinit();

    var index = try GemFile.init(alloc, "index.gmi", output_dir);
    defer index.close();

    const root_mod = data.modules[data.rootMod];
    const root_mod_name = root_mod.name;
    const heading = try std.fmt.allocPrint(alloc, "Generated documentation for: {s}", .{root_mod_name});
    defer alloc.free(heading);
    try index.doc.addHeading(.h1, heading);
    try index.doc.addText("This is the index file for a set of gemini documents rendered from data generated by Zig's Autodoc for this module.");
    try index.doc.addLink("by_ns/index.gmi", "Default documentation (by namespace)");
    try index.doc.addLink("by_file/index.gmi", "Documentation by file");
    try index.doc.addLink("modules.gmi", "All modules");
    try index.doc.addLink("src/index.gmi", "Rendered source of all files included in the data");
    try index.doc.addHeading(.h2, "Links:");
    if (options.project_page) |page| {
        try index.doc.addHeading(.h3, "This project:");
        try index.doc.addLink(page, options.project_name);
        try index.doc.addHeading(.h3, "Other links:");
    }
    try index.doc.addLink("https://ziglang.org", "Zig programming language");
    try index.doc.addLink("https://github.com/der-teufel-programming/zirkon-docs", "Zirkon - the tool used to create this page");

    try index.finalize();
    try renderSources(alloc, output_dir, src_dir_path, data.files);
    var mods_file = try GemFile.init(alloc, "modules.gmi", output_dir);
    defer mods_file.close();
    try renderModules(alloc, &mods_file, data.modules);
    try mods_file.finalize();
}

const GemFile = struct {
    file: std.fs.File,
    doc: render.Document,

    pub fn init(alloc: std.mem.Allocator, file_path: []const u8, dir: std.fs.Dir) !GemFile {
        var doc = render.Document.init(alloc);
        var file = try dir.createFile(file_path, .{});
        return .{
            .doc = doc,
            .file = file,
        };
    }

    pub fn close(self: GemFile) void {
        self.file.close();
        self.doc.deinit();
    }

    pub fn finalize(self: *GemFile) !void {
        try self.doc.renderTo(self.file.writer());
        self.doc.text.clearRetainingCapacity();
    }
};

fn renderSources(
    alloc: std.mem.Allocator,
    output_dir: std.fs.Dir,
    src_dir_path: []const u8,
    files: []const autodoc.File,
) !void {
    var src_dir = output_dir.openDir("src", .{}) catch |err| blk: {
        switch (err) {
            error.FileNotFound => {
                try output_dir.makeDir("src");
                break :blk try output_dir.openDir("src", .{});
            },
            else => return err,
        }
    };
    defer src_dir.close();

    var raw_src_dir = try std.fs.cwd().openDir(src_dir_path, .{});
    defer raw_src_dir.close();

    var src_idx = try GemFile.init(alloc, "index.gmi", src_dir);
    defer src_idx.close();

    try src_idx.doc.addHeading(.h1, "Sources");

    var elems = std.ArrayListUnmanaged([]const u8){};
    defer elems.deinit(alloc);

    for (files) |file| {
        const gen_name = try std.fmt.allocPrint(alloc, "{s}.gmi", .{std.fs.path.basename(file.name)});
        defer alloc.free(gen_name);

        var ci = try std.fs.path.componentIterator(file.name);
        defer elems.clearRetainingCapacity();
        while (ci.next()) |comp| {
            try elems.append(alloc, comp.name);
        }
        const file_link = try std.mem.join(alloc, "/", elems.items);
        defer alloc.free(file_link);
        _ = elems.pop();
        try elems.append(alloc, gen_name);
        const real_link = try std.mem.join(alloc, "/", elems.items);
        defer alloc.free(real_link);

        try src_idx.doc.addLink(real_link, file_link);

        const output_file = if (elems.items.len > 1) blk: {
            var dir = try src_dir.makeOpenPath(std.fs.path.dirname(file.name) orelse ".", .{});
            defer dir.close();
            break :blk try dir.createFile(std.fs.path.basename(gen_name), .{});
        } else try src_dir.createFile(gen_name, .{});
        defer output_file.close();

        const f = raw_src_dir.openFile(file.name, .{}) catch {
            try output_file.writer().print("# {s}\n## Error:\nThis source rendering is unfortunately empty", .{file_link});
            continue;
        };
        defer f.close();

        var buff = std.io.bufferedReader(f.reader());
        var reader = buff.reader();
        var r = render.ZigRender.init(alloc, true);
        defer r.deinit();

        try gemini_render.genSrc(alloc, reader, file_link, &r);
        try r.doc.renderTo(output_file.writer());
    }

    try src_idx.finalize();
}

fn renderModules(alloc: std.mem.Allocator, modules_file: *GemFile, modules: []const autodoc.Module) !void {
    for (modules) |mod| {
        const link = try std.fmt.allocPrint(alloc, "mods/{s}.gmi", .{mod.name});
        defer alloc.free(link);
        try modules_file.doc.addLink(link, mod.name);
    }
}
